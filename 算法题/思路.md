1 重建二叉树

前序遍历：中左右； 中序遍历：左中右； 后序遍历：左右中

如何建立二叉树采用递归，先建立根节点。再建立左子树右子树。

```
build(){
root = new node;
root.left = build()
root.right = build()
}
```

维护两个数组与左右子树下标。

非递归法

2 链表是否有环

快慢指针

慢指针走一步，快指针走两步若快慢指针相遇，则有环，否则快指针遇到最后一个节点退出。

3 判断二叉树是否对称

迭代

两个栈来存储左右子树的节点进行比较

递归

issym（left，right）{

}

4 跳台阶

递归



动态规划，根据前两步算出后一步

f（0）=1

f（1）=1

f（2）=2

f（3）= f（2）+f（1） f（1）与f（2）可以用两个变量来表示

