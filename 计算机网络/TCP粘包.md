**实质**

应用层的一条消息过长，无法封装在一个报文段内，一次性传输给接收方，所以被拆分。但是发送方为了提高传输效率，尽量等待缓冲区满后才会发送，所以这条消息的后面可能紧跟了另一条消息。也可能是因为传输过程中发生拥塞，或者接收端处理不及时，导致在接收端收到几条消息混合的流数据。所以要解决的问题实质是应用程序能够分辨出每一条消息。

**产生背景**

socket网络编程中为了传输高效，将多次间隔较小，数据量较小的数据合并成一个数据量大的数据块，然后进行封包。因此接收端必须使用高效的拆包方法来分辨这些数据。

**TCP粘包**

发送方的若干数据到达接收方时粘成了一包，从接收缓冲区来看，后一包的头紧接着前一包的尾，出现粘包的原因是多方面的，可能来自发送方，也可能是来自接收方。

**原因**

1 发送方原因：TCP为了减少网络中报文段的数据量，采用Nagle算法，这个算法做两件事：

1 只有上一个小组得到确认，才会发送下一个分组

2收集多个小分组，在一个确认来到时一起发送

因此可能出现粘包

2 接收方原因：TCP收到数据包不会马上交到应用层处理。实际上TCP将接收到的包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相连粘到一起的包。

**什么时候需要处理粘包现象**

1 如果发送发发送的多组数据本来就是同一块数据的不同部分，比如一个文件被拆分成多个部分发送，这时当然不需要处理粘包现象

2 多个组毫不相干，甚至是并列关系，就需要处理粘包现象了

**如何处理粘包现象**

1 发送方：关闭Nagle算法。

2 接收方：交给应用层处理。应用层解决方法：**循环处理**，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度？

（1）格式化数据：每条数据有固定的格式（开始符，结束符）。

（2）发送长度，发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。

**udp会不会产生粘包问题**

不会，为了保证可靠传输并减少额外的开销，tcp采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的

UDP则是面向消息传输，有保护消息边界，接收方一次只接受一条独立信息，所以不存在粘包问题。