### **属性**

```c
#include<sys/types.h>
#include<sys/socket.h>
int socket(int domain, int type, int protocol);
```

1 域（domain）：套接字通信使用的网络介质

2 类型（type）：

- **流套接字（SOCK_STREAM）：**

- **数据报套接字（SOCK_DGRAM）：**

- **原始套接字（SOCK_RAW）：**原始套接字与标准套接字（标准套接字指的是前面介绍的流套接字和数据报套接字）的区别在于：原始套接字可以读写内核没有处理的IP数据包，而流套接字只能读取TCP协议的数据，数据报套接字只能读取UDP协议的数据。因此，**如果要访问其他协议发送数据必须使用原始套接字**。

3 协议（protocal）

- 0： 使用默认协议；

- IPPROTO_TCP： 使用TCP协议；

- IPPROTO_UDP： 使用UDP协议；

### **socket缓冲区**

**每个socket创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。**

write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。
  read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。

- I/O缓冲区在每个TCP套接字中单独存在；
- I/O缓冲区在创建套接字时自动生成；
- 即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
- 关闭套接字将丢失输入缓冲区中的数据。

### 使用write/send发送数据

**阻塞模式下**

首先会检查缓冲区，**如果缓冲区的可用空间长度小于要发送的数据，那么 write()/send() 会被阻塞（暂停执行）**，直到缓冲区中的数据被发送到目标机器，腾出足够的空间，才唤醒 write()/send() 函数继续写入数据；

如果TCP协议正在向网络发送数据，那么输出缓冲区会被锁定，不允许写入，write()/send() 也会被阻塞，直到数据发送完毕缓冲区解锁，write()/send() 才会被唤醒。

如果要写入的数据大于缓冲区的最大长度，那么将分批写入。直到所有数据被写入缓冲区 write()/send() 才能返回。

send()函数默认情况下会使用Nagle算法。**Nagle算法通过将未确认的数据存入缓冲区直到积攒到一定数量一起发送的方法，来降低主机发送零碎小数据包的数目**。

**非阻塞模式下**

send()函数的过程仅仅是将数据拷贝到协议栈的缓冲区而已，如果缓冲区可用空间不够，则尽可能拷贝，返回成功拷贝的大小；如果缓存区可用空间为0，则返回-1，同时设置errno为EAGAIN。

### 使用read/recv读取数据

**阻塞模式下**

首先会检查缓冲区，**如果缓冲区中有数据，那么就读取，否则函数会被阻塞，直到网络上有数据到来**；如果要读取的数据长度小于缓冲区中的数据长度，那么就**不能一次性将缓冲区中的所有数据读出，剩余数据将不断积压**，直到读取到数据后 read()/recv() 函数才会返回，否则就一直被阻塞。

**非阻塞模式**

### TCP服务端一直sleep，客户端发送数据问题

**（1）TCP发送数据过程：**

1 数据首先由应用程序缓冲区复制到发送端的输出缓冲区（位于内核），注意这个过程是用类似write功能的函数完成的。有的人通常看到write成功就以为数据发送到了对端主机，其实这是错误的，write成功仅仅表示数据成功的由应用进程缓冲区复制到了输出缓冲区。

2 然后内核协议栈将输出缓冲区中的数据发送到对端主机，注意这个过程不受应用程序控制，而是发送端内核协议栈完成，其中包括使用滑动窗口、拥塞控制等功能。

3 数据到达接收端主机的输入缓冲区，注意这个接收过程也不受应用程序控制，而是由接收端内核协议栈完成，其中包括发送ack确认等。

4 数据由套接字接收缓冲区复制到接收端应用程序缓冲区，注意这个过程是由类似read等函数来完成。

**（2）阻塞方式的情况**

阻塞方式下，如果服务端一直sleep不接收数据，而客户端一直write，也就是只能执行上述过程中的前三步，**这样最终结果肯定是接收端的输入缓冲区和发送端的输出缓冲区都被填满，这样write就无法继续将数据从应用程序复制到发送端的输出缓冲区了，从而使进程进入睡眠**。

**（3）非阻塞情况下**

服务端一直sleep，客户端一直write数据的结果：开始客户端write成功，随着客户端write，接收端的输入缓冲区和发送端的输出缓冲区会被填满。当发送端的输出缓冲区的可用空间小于write请求写的字节数时，write立即返回-1，并将errno置为EWOULDBLOCK。