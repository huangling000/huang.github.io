## synchronized

### synchronized的特性

**原子性**：要么全部执行，要么不执行（volatile不具备原子性）

**可见性**：可见性，synchronized与volatile都是有可见性的。它们的区别在于，synchronized会获得一个类或者对象的锁，获得这个锁之后，若其他线程也想访问这个类或者对象，可以看到它们的锁的情况，当前是否被其他线程持有，如果其他线程持有这个锁，那么就会等待其他线程释放锁。如果当前线程正拥有锁，那么在释放锁之前，将会把该对象更新的数据全部刷到主存中（java堆中），因此对类或者对象的修改对其他线程而言是可见的。而被volatile修饰的类或者对象是在它们的数据被刷新的那一刻，立刻刷新到主存中，因此对其他线程来讲，能够读到的永远是最新值，修改也是可见的。**对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值**

**有序性**：代码执行顺序是按照代码顺序执行的。synchronized与volatile都具有有序性。java允许编译器预处理器对指令进行重排，但是指令重排不会影响单线程执行顺序，他影响多线程并发的执行顺序。被synchronized修饰的代码在多线程访问时，其中一个线程会获得一个锁，保证资源的访问具有先后顺序。

**可重入性**：可以对已经获得锁的对象再一次申请锁。synchronized与reentrantlock都是可重用锁。

### synchronized的用法

synchronized可以对静态方法，成员函数或者代码块加锁，但实质上他都是对两种资源的加锁：类和对象。

### synchronized锁的实现

有两种上锁方式，一个是对方法上锁，一个是构造代码同步块。但他们的底层实现都是一样的，需要先获取类或者对象的锁，然后再进入同步代码块。当获得锁时，资源的锁计数器+1，释放锁时，锁计数器-1.当获取失败，则阻塞式等待锁的释放。只是他们在同步块识别方式上有所不一样，从class字节码文件可以表现出来，一个是通过方法flags标志，一个是monitorenter和monitorexit指令操作。

**方法上锁**

可以看到在add方法的flags里面多了一个`ACC_SYNCHRONIZED`标志，这标志用来告诉JVM这是一个同步方法，在进入该方法之前先获取相应的锁，锁的计数器加1，方法结束后计数器-1，如果获取失败就阻塞住，知道该锁被释放。

当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。**在方法执行期间，其他任何线程都无法再获得同一个monitor对象。**

**代码块上锁**

同步块是由monitorenter指令进入，然后monitorexit释放锁，在执行monitorenter之前需要尝试获取锁，如果这个对象没有被锁定，或者当前线程已经拥有了这个对象的锁，那么就把锁的计数器加1。当执行monitorexit指令时，锁的计数器也会减1。当获取锁失败时会被阻塞，一直等待锁被释放。

**Synchronized的语义底层是通过一个monitor的对象来完成，其实wait/notify等方法也依赖于monitor对象，这就是为什么只有在同步的块或者方法中才能调用wait/notify等方法，否则会抛出java.lang.IllegalMonitorStateException的异常的原因。**



两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是JVM通过调用操作系统的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。

### synchronized底层实现

**synchronized给出的答案是在软件层面依赖JVM，而j.u.c.Lock给出的答案是在硬件层面依赖特殊的CPU指令。**

**对象**

三部分：对象头，实例数据，对齐填充。实例数据存放类的属性数据信息，父类的属性数据信息，如果是数组的实例部分还包括数组的长度。**对其填充**不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对齐填充仅仅是为了使字节对齐。

对象头的主要数据结构：mark word和class metadata address。mark word中存储对象（对象的运行时数据）的哈希码（HashCode）、GC分代年龄、**锁状态标志**、线程持有的锁、偏向线程 ID、偏向时间戳等。class metadata address是类型指针指向对象的类元数据，jvm通过这个指针明白这是哪个类的实例。

jdk6之前，锁只有：有锁和无锁（重量级锁）两种状态。jdk6之后对synchronized进行优化，锁的状态有了：**无锁状态、偏向锁、轻量级锁、重量级锁**。锁的类型和状态存储在对象头mark word中都有记录。申请锁，升级锁都要读取对象的mark word。

每一个锁都对应一个**monitor对象**，在HotSpot虚拟机中它是由ObjectMonitor实现的（C++实现）。每个对象都存在着一个monitor与之关联，对象与其monitor之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。

```java
ObjectMonitor() {
    _header       = NULL;
    _count        = 0;  //锁计数器
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

ObjectMonitor中有两个队列_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。  monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)

### jvm对synchronized的优化

**锁膨胀**

上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：**无锁——>偏向锁——>轻量级锁——>重量级锁**，并且膨胀方向不可逆。

**1 偏向锁**

**减少统一线程获取锁的代价**。在大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得，那么此时就是偏向锁。

如果一个线程获得了锁，那么锁就进入偏向模式，此时`Mark Word`的结构也就变为偏向锁结构，**当该线程再次请求锁时，无需再做任何同步操作，即获取锁的过程只需要检查**`Mark Word`**的锁标记位为偏向锁以及当前线程ID等于**`Mark Word`**的ThreadID即可**，这样就省去了大量有关锁申请的操作。

**2 轻量级锁**

轻量级锁是由偏向锁升级而来，当存在**第二个线程申请同一个锁对象**时，偏向锁就会立即升级为轻量级锁。注意这里的第二个线程只是申请锁，不存在两个线程同时竞争锁，可以是一前一后地交替执行同步块。

**3 重量级锁**

重量级锁是由轻量级锁升级而来，当**同一时间**有多个线程竞争锁时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。

重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。

**锁消除**

**锁粗化**

锁粗化是虚拟机对另一种极端情况的优化处理，通过扩大锁的范围，避免反复加锁和释放锁。

**自旋锁和自适应自旋锁**

