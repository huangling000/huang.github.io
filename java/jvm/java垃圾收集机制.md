参考原文：[https://blog.csdn.net/ns_code/article/details/18076173](https://blog.csdn.net/ns_code/article/details/18076173)

### 对象引用

java中的垃圾回收一般是在java堆中进行，因为堆中几乎存放了java中所有的对象实例。jdk1.2之前：referrence类型数据中存储的数值代表另一块内存的起始地址，则代表一个引用。jdk1.2之后：强引用，软引用，弱引用，虚引用，引用强度依次递减。

**强引用Strong Reference**：如“Object obj = new Object（）”，这类引用是Java程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。

**软引用Soft Reference**：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。

**弱引用Weak Reference**：它也是用来描述非需对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

**虚引用Phantom Reference**：最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。

### 垃圾对象的判定

java堆中存放着几乎所有的对象实例，垃圾收集器对堆中的对象进行回收前，要先确定这些对象是否还有用，判定对象是否为垃圾对象有如下算法：

**引用计数算法：**

**给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失效时，计数器值就减1，任何时刻计数器都为0的对象就是不可能再被使用的。**

引用计数算法的实现简单，判定效率也很高，在大部分情况下它都是一个不错的选择。但java语言并没有选择这种算法来进行垃圾回收，因为它**很难解决对象之间互相循环应用问题。**

**根搜索算法**

java与c#都是采用根搜索算法来判定对象是否存活的。这种算法的基本思路是通过一系列名为**”GC Roots“的对象作为起始点**，从这些几点开始向下搜索，**搜索所走过的路径称为引用链**，**当一个对象到GC Roots没有任何引用链相连时，就证明此对象是不可用的**。在java语言里，可作为GC Roots的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中的类静态属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中JNI（Native方法）的引用对象

实际上，在根搜索算法中，要真正宣告一个对象死亡，至少要经历**两次标记过程**：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那么它会被**第一次标记并且进行一次筛选**，筛选的条件是此**对象是否有必要执行finalize（）方法**。当对象没有覆盖finalize（）方法，或finalize方法已经被虚拟机调用过，虚拟机将这两种方法都视为没有必要执行。如果该对象被判定为有需要执行finalize方法，那么该对象将会被放置在一个名为F-Queue的队列中，并在稍后由一条虚拟机自动建立的，低优先级的Finalizer线程去执行finalize方法。finalize方法是对象逃脱死亡命运的最后一次机会**（因为一个对象的finalize（）方法最多只会被系统自动调用一次）**，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize（）方法中成功拯救自己，只要在finalize（）方法中让该对象重引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。

### 垃圾收集算法

标记-清除算法

最基础的收集算法，分为**“标记“和“清除”**两个阶段：

首先标记所需回收的对象，在标记完成后统一回收掉所有被标记的对象。标记过程就是前面的根搜索算法中判定垃圾对象的标记过程。

缺点：

* 标记和清除过程的效率都不高
* 标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序以后运行过程中需要分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。

**复制算法**

复制算法针对标记-清除算法的缺点，在其基础上改进得到，它将可用内存按容量分为大小相等的两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块内存上面，然后再把使用过的内存空间一次清理掉。

优点：

1 每次只对一块内存进行回收，运行高效

2 只需移动栈顶指针，按顺序分配内存即可，实现简单。

3 内存回收时不用考虑内存碎片的出现

缺点：可一次性分配的内存缩小的一半。

回收前状态：

![](https://img-blog.csdn.net/20140110123902531)

回收后状态：

![](https://img-blog.csdn.net/20140110123941765)

**标记-整理算法**

复制算法比较适于新生代，在老年代中，对象存活率比较高，如果执行较多的复制操作，效率将会变低，所以老年代一般会选择其他算法，如：标记-整理算法。该算法标记对象的过程与标记-清除算法中标记过程一样，但它不是直接将可回收对象进行清理，而是让所有对象向一端移动，然后直接清理掉端边界以外的内存。标记-整理算法回收情况如下：

回收前：

![](https://img-blog.csdn.net/20140110124255984)

回收后：

![](https://img-blog.csdn.net/20140110124356484)



![](https://img-blog.csdn.net/20140110123602734)

**分代收集**

当前商业虚拟机的垃圾收集都采用分代收集，它根据对象的存活周期的不同，将内存划分为几块，一般把java堆分为新生代和老年代。在新生代中，每次垃圾收集时都会有大量对象死去，只有少量存活，因此可选择复制算法来完成收集，而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用使用标记-清除算法或标记-整理算法。

### 垃圾回收分析

对内存的分配策略：

* 对象优先在eden分配
* 大对象直接进入老年代
* 长期存活的对象进入老年代

新生代与老年代GC：

* 新生代GC（Minor GC）：发生在新生代的垃圾收集动作，大多java对象存活的时间都不长，因此Minor GC非常频繁，回收速度也比较快。
* 老年代GC（Major/Full GC）：发生在老年代的GC，出现了Major GC，经常会伴随至少一次Minor GC。由于老年代中的对象生命周期都比较长，因此Minor GC并不频繁，一般都是等待老年代满了后才进行Full GC，而且其速度一般会比Minor GC慢10倍以上。另外，如果分配了Direct Memory，在老年代中进行Full GC时，会顺便清理掉Direct Memory中的废弃对象。

**一个对象能否被回收的根本原因是局部变量表中的Slot是否还存有关于该对象的引用**。

```
public class SlotGc{
	public static void main(String[] args){
		{
		byte[] holder = new byte[32*1024*1024];
		}
		System.gc();
	}
}
```

输出：

[GC 208K->134K(5056K), 0.0017100 secs]

[Full GC 134K->134K(5056K), 0.0125887 secs]

[Full GC 32902K->32902K(37828K), 0.0089226 secs]

```
public class SlotGc{
	public static void main(String[] args){
		{
		byte[] holder = new byte[32*1024*1024];
		holder = null;
		}
		System.gc();
	}
}
```



输出：

[GC 208K->134K(5056K), 0.0017194 secs]

[Full GC 134K->134K(5056K), 0.0124656 secs]

[Full GC 32902K->134K(37828K), 0.0091637 secs]

为对象赋null值并不是控制变量回收的最好方法，以恰当的变量作用域来控制变量回收时间才是最优雅的解决办法。

### 性能调优

java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序的性能和稳定性有着非常重要的影响。性能调优需要具体情况具体分析，而且实际分析时可能需要考虑的方面很多

* 我们可以通过给Java虚拟机分配**超大堆**（前提是物理机的内存足够大）来提升服务器的响应速度，但分配超大堆的前提是有把握把应用程序的**Full GC频率控制得足够低，因为一次Full GC的时间造成比较长时间的停顿**。控制Full GC频率的关键是保证应用中**绝大多数对象的生存周期不应太长**，尤其不能产生批量的、生命周期长的大对象，这样才能**保证老年代的稳定**。
* Direct Memory在堆内存外分配，而且二者均受限于物理机内存，且成负相关关系，因此分配超大堆时，如果用到了NIO机制分配使用了很多的Direct Memory，则有可能导致Direct Memory的OutOfMemoryError异常，这时可以通过-XX:MaxDirectMemorySize参数调整Direct Memory的大小。
* 除了Java堆和永久代以及直接内存外，还要注意下面这些区域也会占用较多的内存，这些内存的总和会受到操作系统进程最大内存的限制：1、线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError（纵向无法分配，即无法分配新的栈帧）或OutOfMemoryError（横向无法分配，即无法建立新的线程）。2、Socket缓冲区：每个Socket连接都有Receive和Send两个缓冲区，分别占用大约37KB和25KB的内存。如果无法分配，可能会抛出IOException：Too many open files异常。3、JNI代码：如果代码中使用了JNI调用本地库，那本地库使用的内存也不在堆中。4、虚拟机和GC：虚拟机和GC的代码执行也要消耗一定的内存。

