原文参考：[https://blog.csdn.net/ns_code/article/details/17675609](https://blog.csdn.net/ns_code/article/details/17675609)

## 平台无关性

不仅java编译器可以将java代码编译成class文件，其它语言的编译器也可以将程序代码编译成class文件。java虚拟机不关心Class文件的来源，只要符合一定的结构，就能在虚拟机中运行。字节码命令所能提供的语义描述能力比Java语言本身更强大，为其他语言实现一些有别于java的语言特性提供了基础，也是类加载时要进行安全验证的原因。

## 类文件结构

Class文件是一组以8字节为基础单位的二进制流，各个数据项目严格紧凑地排列在Class文件中，中间没有任何分隔符，使得整个Class文件中存储的内容几乎全部都是程序运行地必要数据。根据java虚拟机规范地规定，Class文件格式采用一种类似于C语言结构体地伪结构来存储，这种伪结构只有两种数据类型：无符号数和表。

整个Class文件本质就是一张表

![](https://img-blog.csdn.net/20131230204449140)

### **magic与version**：

每个文件头4个字节为magic，用于判断该文件是否是一个能被虚拟机接受的Class文件，是一个固定值：0xCAFEBABE。紧接着存储version，4个字节，主版本号与次版本号。高版本jdk能向下兼容低版本class文件，但不能运行更高版本class文件。

### **constant pool**：

常量池的入口，是class文件中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一。

主要存放两类常量：字面量和符号引用。字面量接近于java层面常量概念，如文本字符串，被声明为final的常量值等。而符号引用则包括：1 类和接口的全限定名（带有包名的Class名）；2 字段的名称和描述符（private，static）；3 方法的名称和描述符（private，static）

虚拟机在加载Class文件时才会进行动态连接，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。

**符号引用和直接引用的区别与关联**

* 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现地内存布局无关，引用的目标并不一定加载到内存中。
* 直接引用：直接引用是可以直接指向目标的指针/相对偏移量/或是一个能间接定位到目标的句柄。直接引用是与虚拟机的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明应用的目标必定已经存在于内存之中了。

常量池中的每一项常量都是一个表，共有11种（JDK1.7之前）结构各不相同的表结构数据，没中表开始的第一位是一个u1类型的标志位（1-12，缺少2），代表当前这个常量属于的常量类型。11种常量类型所代表的具体含义如下表所示：

![](https://img-blog.csdn.net/20131230213306531)

这11种常量类型各自均有自己的结构。在CONSTANT_Class_info型常量的结构中有一项name_index属性，该常属性中存放一个索引值，指向常量池中一个CONSTANT_Utf8_info类型的常量，该常量中即保存了该类的全限定名字符串。而CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info型常量的结构中都有一项index属性，存放该字段或方法所属的类或接口的描述符CONSTANT_Class_info的索引项。另外，**最终保存的诸如Class名、字段名、方法名、修饰符等字符串都是一个CONSTANT_Utf8_info类型的常量，也因此，Java中方法和字段名的最大长度也即是CONSTANT_Utf8_info型常量的最大长度**，在CONSTANT_Utf8_info型常量的结构中有一项length属性，它是u2类型的，即占用2个字节，那么它的最大的length即为65535。因此，**Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。**

### acces_flag

常量池结束后，紧接着是两个字节代表**访问标志**，用于识别一些**类或接口的访问信息**：如这个class是类还是接口，是否定义为public，abstract，如果是类是否声明为final。

每种访问信息都由一个十六进制的标志值表示。

### this_class、super_class、interfaces

类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）则是一组u2类型的数据集合，用于确定这个类的继承关系.

### fields

field_info用于描述接口或类中声明的变量。字段包括了类级变量或实例级变量，但不包括在方法内声明的变量。字段的名字，数据类型，修饰符等都是无法固定的，只能引用常量池中的常量来描述。

![](https://img-blog.csdn.net/20140102184434718)

**描述符**：描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序等）和返回值的。

**字段表集合中不会列出从父类或接口中继承而来的字段，但有可能列出原本Java代码中不存在的字段。**比如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。

### methods

method_info结构与属性表的结构相同。

与字段表集合相对应，如果父类方法在子类中没有被覆写，方法表集合中就不会出现来自父类的方法信息。但同样，有可能会出现由编译器自动添加的方法，最典型的便是类构造器“<clinit>”方法和实例构造器“<init>”方法。

在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称外，还要求必须拥有一个与原方法不同的**特征签名**，特征签名就是一个方法中**各个参数在常量池中的字段符号引用的集合**。

### attributes

属性表（attribute_info）在前面已经出现过多次，在Class文件、字段表、方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。

对于每个属性，它的名称都需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，每个属性值的结构是完全可以自定义的，只需说明属性值所占用的位数长度即可。一个符合规则的属性表至少应具有“attribute_name_info”、“attribute_length”和至少一项信息属性。

  1）Code属性

Java程序方法体中的代码讲过Javac编译后，生成的字节码指令便会存储在Code属性中，但并非所有的方法表都必须存在这个属性，比如接口或抽象类中的方法就不存在Code属性。

![](https://img-blog.csdn.net/20140102194107312)

异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常即finally处理机制，也因此，finally中的内容会在try或catch中的return语句之前执行，并且在try或catch跳转到finally之前，会将其内部需要返回的变量的值复制一份副本到最后一个本地表量表的Slot中。

**Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码和元数据两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。**

 2）Exception属性

3）LineNumberTable属性

  它用于描述Java源码行号与字节码行号之间的对应关系。

4）LocalVariableTable属性

  它用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的对应关系

5）SourceFile属性

  它用于记录生成这个Class文件的源码文件名称。

6）ConstantValue属性

通知虚拟机为静态变量赋值。只有修饰符为 static final 的且为基本类型或string的变量，才会有ConstantValue属性。

 7）InnerClasses属性

  该属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那么编译器将会为它及它所包含的内部类生成InnerClasses属性。

  9）Synthetic属性

  该属性代表此字段或方法并不是Java源代码直接生成的，而是由编译器自行添加的，如this字段和实例构造器、类构造器等。