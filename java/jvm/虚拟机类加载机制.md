原博参考：[https://blog.csdn.net/ns_code/article/details/17881581](https://blog.csdn.net/ns_code/article/details/17881581)

### 类加载机制的种类：

**全盘负责**，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入

**双亲委托机制：**先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类

**缓存机制**，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

## 类加载过程

生命周期：加载，连接（验证，准备，解析），初始化，使用，卸载

加载，验证，准备，初始化，卸载五个阶段顺序是确定的，类加载过程必须按照这种顺序按部就班的开始，解析阶段不一定。

解析阶段可能在初始化后再开始，为了支持java的运行时绑定（动态绑定）。

这几个阶段通常是按顺序开始，而不是按顺序执行或完成，会混合交叉进行完成

**绑定**：把一个方法的调用与方法所在的类关联起来，对java来说，绑定分为静态绑定和动态绑定。

静态绑定：前期绑定，在程序执行前方法已经被绑定，此时由编译器或其他连接程序实现。java当中的方法只有final，static，private和构造方法是前期绑定的。

动态绑定，晚期绑定，也叫运行时绑定，在运行时根据具体对象的类型进行绑定。在java中，几乎所有方法都是后期绑定的





### **加载**

通过一个类的全限定名来获取此类的**二进制字节流**（不一定是从Class文件中获取，如：网络，动态生成，数据库）

将这个字节流所代表的**静态存储结构**转化为**方法区的运行时数据**。

在**内存（java堆）**中生成一个代表这个类的**java.lang.Class对象**，作为方法区这个类的各种**数据的访问入口**。

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的**开始时间**仍然保持着固定的先后顺序。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区中，而且在java堆中创建一个java.lang.Class对象，通过该对象访问方法区中的这些数据。

**类加载器**

对于任意一个类，都需要由他的类加载器和这个类本身一同确定在这个java虚拟机中的唯一性。即，即便两个类来自同一个class文件，只要加载它们的类加载器不同，那这两个类就不相等。“相等”包括了代表类的Class对象的euqals(), isAssignableFrom(), isInstance()等方法的返回结果，也包括使用instanceof关键字对象所属关系的判定结果。

在java虚拟机的角度，只存在两种不同的类加载器：

* 启动类加载器：由C++语言实现，是虚拟机自身的一部分。
* 其他所有的类加载器：由java语言实现，独立于虚拟机之外，并且全部抽象自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存之中后才能去加载其他类。

java开发人员角度，可以划分为三类：

* **启动类加载器**：Bootstrap ClassLoader。它负责加载存放在**jdk/jre/lib**下，或被**-Xbootclasspath**参数指定的路径中的，并且能够被虚拟机识别的类库。启动类加载器是无法被java程序直接引用的。
* 扩展类加载器：Extension ClassLoader，负责加载**jdk/jre/lib/ext**目录中或者由**java.net.dirs**系统变量指定路径中的所有类库（如：javax.*开头的类），开发者可以直接使用扩展类加载器。
* 应用程序类加载器：Application Classloader，该类加载器负责用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果程序中没有定义过自己的类加载器。一般情况默认。

**jvm自带的ClassLoader只懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到：**

* 在执行非置信代码之前，自动验证数字签名；

* 从特定场所取得java class，例如数据库和网络中；

* 动态创建符合用户特定需要的定制化构建类

事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。

**双亲委派模型**

这几种类加载器的层次关系：

![](http://assets.processon.com/chart_image/6044796d6376897969e19363.png)

这种**层次关系**称为类加载器的**双亲委派模型**。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，但他们间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在jdk1.2期间被引入并广泛应用于之后几乎所有的java程序中，但它并不是一个强制的约束模型，而是java设计者们推荐给开发者的一种类加载器的实现方式。

双亲委派模型的工作流程：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载器请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。

**实现**

分为两步：

1 从底向上地检查类是否已经加载过

2 如果没有加载过，就自顶向下的尝试加载该类。

```
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // First, check if the class has already been loaded
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                try {
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }

```



使用双亲委派模型组织类加载器之间的关系，有一个明显的好处：**java类随着它的类加载器（可以理解为类所在的目录）一起具备了一种带有优先级的层次关系，这对于保证java程序的稳定运作很重要**。

类java.lang.Obecjt无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，保证了Object类在程序中的各种类加载器中都是同一类。通过这种层级关系**可以避免类的重复加载，当父类已经加载了该类时，就没有必要子类加载器再加载一次**。

考虑到安全因素，**java核心api中定义类型不会被随意替换，基础类得到统一**，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委派模型传递到启动类加载器，而启动类加载器在核心API发现这个名字的类，发现该类已经被加载，并不会重新加载网络传递过来的java.lang.Integer，而直接返回java API中的Integer.class，这样便可以防止核心API库被随意篡改。

### 验证

连接阶段的第一步，**确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**

验证阶段大致会完成4个阶段的检验动作：

1. **文件格式**验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、**版本号**是否在当前虚拟机的处理范围之内、**常量池中的常量**是否有不被支持的类型。**这一步主要是保证输入的字节流能够正确地解析并存储在方法区内**，经过该阶段的验证后字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2. **元数据**验证：对字节码描述的信息进行语义分析（注意：**对比javac编译阶段的语义**分析），以保证其描述的信息符合Java语言规范的要求；即对类中的各数据类型进行语法校验，保证不存在不符合Java语法的元数据信息。
3. **字节码**验证：通过数据流和控制流分析，对类的方法体确定**程序语义**是合法的、符合逻辑的。
4. **符号引用验证**：发生在虚拟机将符号应用转化为直接引用的时候，主要是对类自身以外的信息（常量池中的各类符号引用）进行匹配性的校验。

**验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。**

### 准备

**正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。**进行内存分配的变量仅包括**类变量（被static修饰的变量），而不包括实例变量，实例变量在对象实例化的时候随着对象一起分配在堆中**。其次，初始值通常指数据类型的零值。public static int value = 123；value在准备阶段初始值为0，因为现在尚未开始执行任何java方法，赋值动作的指令是程序被编译后存放于类构造器方法<clinit>()内，所以赋值动作在初始化阶段才会执行。

特殊情况，public static final int value = 123；字段属性为ConstantValue，会在初始阶段初始化为指定值。

### 解析

将常量池内的符号引用替换为直接引用。解析动作主要针对类，接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号应用进行。

1 类或接口的解析：判断所要转化成直接引用是对数组类型还是普通对象类型的引用，从而进行不同的解析

2 字段解析：对字段进行解析时，现在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，查找结束；如果没有，则会按照继承关系从下往上递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从下往上递归搜索其父类。**（先接口后父类）**

3 类方法解析：与字段解析相似，但是多了判断该方法所处的是类还是接口的步骤，并且对类方法的匹配是**先父类后接口**

### 初始化

类加载过程的最后一步，到了初始化阶段，才开始真正执行类中定义的java程序代码。在准备阶段，变量已经赋过一次系统要求的初始值，初始化阶段则是程序员根据主观意愿初始化类变量与其他资源。

<clinit>方法：编译器将类中static语句块与变量赋值动作收集到一起产生的，使static语句块在初始化时按照顺序进行执行。**如果这个类存在静态语句块，那么初始化时会执行<clinit>方法，并且子类的<clinit>方法执行前，父类的<clinit>接口也会在这之前被执行。如果一个接口中含有static语句块，那么继承它的子类初始化时，不需要先执行父接口的<clinit>方法。**

<clinit>方法在多线程环境下会被安全加锁，如果多个线程同时初始化一个类，那么只有一个线程回去执行这个类的<clinit>方法，其他线程需要阻塞等待，直到活动线程执行完<clinit>方法。其他线程虽然会被阻塞，但如果执行<clinit>()方法的那条线程退出<clinit>()方法后，其他线程唤醒之后不会再次进入<clinit>()方法。同一个类加载器下，一个类型只会初始化一次。

虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：

1. 遇到new,getstatic,putstatic,invokestatic这失调字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。**常量在编译阶段会存入调用它的类的常量池中，本质上没有直接引用到定义该常量的类，因此不会触发定义常量的类的初始化**

   

   ```java
   
   ```

2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。

3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5. 当使用jdk1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

**通过数组定义来引用类，不会触发此类的初始化。因为数组定义只是一个对数组引用类型的初始化，而数组中的元素仅仅包含一个对Const类的引用，没有实例化对象的操作，不会初始化**

常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

下列输出：

```
public class StaticTest
{
    public static void main(String[] args)
    {
        staticFunction();
    }

    static StaticTest st = new StaticTest();

    static
    {
        System.out.println("1");
    }

    {
        System.out.println("2");
    }

    StaticTest()
    {
        System.out.println("3");
        System.out.println("a="+a+",b="+b);
    }

    public static void staticFunction(){
        System.out.println("4");
    }

    int a=110;
    static int b =112;
}
```

首先普遍的初始化顺序：
		先将初始化变量，再初始化语句块，首先该类作为主类被加载进来，经过验证，准备，解析过程后，开始进行初始化。类构造器进行初始化首先将静态变量按顺序进行初始化，遇到的第一个静态变量是该类本身的一个对象，所以需要对st对象进行初始化，先初始化成员a=110，再初始化语句块，输出2，然后执行构造函数。输出3，以及此时a已经被赋值110，但b仍未进行赋值操作，仍然是准备阶段被赋予的0.然后向下执行为b赋值112。然后初始化静态语句块，输出1。最后main方法中调用staticFunction（）方法，输出4.

### 总结

类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于<clinit>（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。
