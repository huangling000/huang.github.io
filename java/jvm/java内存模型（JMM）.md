**java memory model**

### 线程之间的通信：

**共享内存**：线程之间共享程序的公共状态，线程之间通过读写内存中的公共状态来隐式进行通信。典型的共享内存通信方式：**共享对象**

在共享对象的变量中设置信号量。但是容易让线程进入忙等状态，即一直在运行中等待信号量的改变，采用java.lang.object提供的wait，notify等方法可以解决忙等问题，让线程进入等待状态（阻塞状态）。

**消息传递**：这个并发模型里，线程之间没有共享状态，线程间通过发送消息进行显示通信。java中典型的消息传递方式：wait（）和notify（）。

当一个线程调用任何对象的wait方法时，线程都会进入非运行状态，直到另一个线程调用该对象的notify或notifyall方法。

为了能够**调用一个对象的wait，notify方法，调用线程必须先获得这个对象的锁**。因为**线程只有在同步块中才会占用对象的锁**，所以线程必须在同步块中调用wait，notify方法。

*由必须获得一个对象的锁才能调用对象的wait等方法，我们可以想到，1 如果没有获得对象的锁直接调用对象的wait或notify方法，会抛出异常。2 在使用一个线程使用了某个对象的wait方法后，线程会释放这个对象的锁。这时其他线程则能够获取该对象的锁进行唤醒，不会存在在调用wait方法同步块中线程一直获得对象锁导致其他线程阻塞。3 但在一个线程同步块获得锁并调用对象的notify方法后，线程并不会直接释放锁，要等同步块执行完成后释放锁，使用wait方法的线程才能获得锁够退出wait方法，被唤醒。*

### 线程之间的同步

程序用于**控制**不同**线程**之间操作发生**相对顺序**的**机制**。

在**共享内存**并发模型里，同步是**显示进行**的。程序员必须显示指定某个方法或某段代码需要在线程之间互斥执行。

在**消息传递**的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是**隐式进行**的。

**java采用共享内存模型**

### java内存模型

JMM决定一个线程对共享内存的写入何时对另一个线程可见。

抽象：线程之间的共享变量存储在**主内存**，每个线程都有一个私有的**本地内存**，本地内存储存了该线程以读写共享变量的副本。**JMM是一个抽象模型，主存实际上包含缓存，写缓冲区，寄存器等等。**

在JMM模型中，线程A与线程B之间通信，首先A中有一个共享变量的副本，A需要把本地内存中的共享变量刷新到主存中，B再从主存中读取更新过的共享变量到自己的本地内存中，实现通信。在JMM中，线程之间的通信都要通过主存。

### jvm实现java内存模型



**支撑java内存模型的基础原理**

**指令重排序**：在执行程序时，为了提高性能，编译器核处理器会对指令做重排序。但是，JMM确保在不同的编译器和不同的处理器平台上，通过**插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序**，为上层提供一致的内存可见性保证。

编译器优化重排序：编译器在不改变单线程程序语义下，可以重新安排语句的执行顺序。

指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

内存系统的重排序：处理器使用缓存和读写缓冲区，使加载和存储操作看上去是在乱序执行。

**编译器和处理器不会改变存在数据依赖性的两个操作执行顺序，不会重排序**

**as-if-serial**

不管如何重排序，单线程下的执行结果不能被改变，编译器，runtime和处理器都必须遵守as-if-serial语义。

**内存屏障**

禁止特定类型处理器和编译器的重排序，让流程被程序员控制。重排序是为了尝试性能优化。

另一个功能：强制刷出各种CPU缓存。如一个写入屏障将刷出所有在内存屏障之前写入缓存的数据，因此任何CPU上都能读取这些数据的最新版本。

**volatile就是基于内存屏障实现的，当一个变量被volatile修饰后，JMM会在写入这个字段后插进一个write-Barrier指令，并在读这个字段之前插入一个read-barrier。**可以保证在写入之后的变量会刷新到各个线程之间，并且在刷新之前的数据对各线程也是可见的。

**happens-before**

在JMM中，如果一个操作要对于另一个操作可见，那么这两个操作之间必须要存在happens-before关系。不是说前一个操作必须要在后一个操作之前执行，仅仅要求前一个操作的执行结果对后一个操作是可见的，且前一个操作按顺序排在后一个操作之前。

程序顺序规则，监视器锁规则，volatile域规则，传递性规则。