### 数据库事务

构成单一逻辑工作单元的操作集合。它可以包含对多个数据库的操作，但这些操作需要构成一个 逻辑上的整体。这个事务的所有操作要么全部成功，要么全部不执行。

不管事务执行是否成功，数据库总能保持一致性状态。

**为什么需要数据库事务**

为了防止用户在使用数据库时因为一些意外而使应该连续的操作发生中断，导致数据库内数据不一致。

**事务如何解决问题**

1 数据库操作失败或系统崩溃，系统能够以事务为边界进行恢复，保持数据库内数据的一致性和持久性。

2 当有多个用户同时操作数据库时，能够以事务为单位进行并发控制，使多个用户的操作相互隔离。

总而言之，事务能够方便的进行故障恢复，以及并发控制，从而保证数据库状态的一致性。

### 事务的ACID特性以及实现原理概述

**原子性(Atomicity)**

事务中的所有操作像原子一样不可分割，要么全部成功，要么全部失败。

**一致性(Consistency)**

事务的执行结果必须使数据库从一个一致性状态到另一个一致性状态。一致性状态是指： 1 系统的状态满足数据的完整性约束 2 系统的状态反应数据库本应描述的现实世界的真实状态

**隔离性（Isolation)**

并发事务执行不会互相影响，其对数据库的影响和它们串行执行时一样。

**持久性（Durability）**

事务一旦提交，其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。

在这几个特性中，C是事务的根本追求，数据一致性的破坏主要来自两个方面：

**1 事务的并发执行**

**2 事务故障或系统故障**

这几个特性主要是依赖**并发控制技术与日志恢复技术**实现。并发控制技术保证事务的隔离性，即多个事务对数据库的操作不会对数据库的一致性产生影响。日志恢复技术保证了数据库的原子性与持久性。在系统崩溃时，通过日志可以恢复对数据库已经提交的修改，并且通过对日志状态的判断，在恢复时判断事务是否完成，未完成则回滚，完成则恢复，保证事务的原子性与一致性。

### 并发异常与并发控制技术

**常见并发异常**

1 脏写：事务一的回滚导致事务二已被提交的数据失效。

2 更新丢失：事务一提交但是使事务二的提交数据好像没有更新一样。

3 脏读： 一个事务读取了另一个事务**未提交**的数据

4 不可重复读： 事务一两次读取的数据因为事务二的**提交**不一样。

5 幻读：事务一**读取某个范围**的数据时，因为事务二的操作导致第二次读取时结果不一样。幻读通常出现在带有查询条件的范围查询中。

**事务的隔离级别**

事务具有隔离性，多个事务执行结果应该与串行执行时一样。但完全的隔离性会导致系统的并发性能低，降低对资源的利用率，所以实际上会降低隔离性的标准，同时造成数据库一致性的降低。

从低到高的隔离级别：

读未提交，读已提交，可重复读，串行化

mysql：设置transaction-isolation

**事务隔离性的实现**

常见的并发控制技术

乐观并发控制：先假定不会真的发生冲突，等到发生冲突之后再解决冲突，比如让事务回滚。

悲观并发控制：对于并发执行的操作，假定其必发生冲突，通过让事务等待（锁）或者中止的方式使并行的操作串行执行

**基于封锁的并发控制**

核心思想，对于并发可能冲突的操作，通过锁使他们互斥执行。锁通常分为共享锁和排他锁两种类型。

1 共享锁（S）：事务对数据A加共享锁，其他事务只能对A加共享锁但不能加排他锁

2 排他锁（X）：事务对A加排他锁，其他事务对A既不能加共享锁。也不能加排他锁。

**基于锁的并发控制流程**

1 事务根据自己对数据项进行的操作**申请相应的锁**（读申请共享锁，写申请排他锁）

2 申请锁的请求被发送给**锁管理器**。锁管理器管理分配锁。

3 若锁被授予,则申请锁的事务可以继续执行;若被拒绝,则申请锁的事务将进行等待,直到锁被其他事务释放。

可能出现的问题：

* 死锁：多个事务持有锁并互相循环等待其他事务的锁导致所有事务都无法继续执行。
* 饥饿：数据线A一直被加共享锁，其他事务一直无法获取A的排他锁。

**基于时间戳的并发控制**

核心思想:对于并发可能冲突的操作,基于时间戳排序规则选定某事务继续执行,**其他事务回滚**。

**基于有效性检查的并发控制（乐观）**

核心思想:事务对数据的更新首先在自己的工作空间进行,等到要写回数据库时才进行有效性检查,对不符合要求的事务进行回滚。

**基于快照隔离的并发控制（乐观）**

快照隔离是多版本并发控制(mvcc)的一种实现方式。

其核心思想是:数据库为每个数据项维护多个版本(快照),每个事务只对属于自己的私有快照进行更新,在事务真正提交前进行有效性检查,使得事务正常提交更新或者失败回滚。