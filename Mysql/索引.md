**什么时候需要使用索引**

主键建立唯一索引

经常用于查询的列

需要排序的列

用于聚合函数的列

高并发下的组合索引

外键建立索引

**什么时候不要使用索引**

大量增删改的列

大量重复的列

表数据太少

**索引失效的情况**

组合索引不能有null

一个select语句只能用一次索引

like操作中'%aaa%'不会使用索引

索引列上使用函数表达式

查询条件为不等于，大于，小于

类型不一致

***在查询条件中使用OR连接多个条件会导致索引失效，除非OR链接的每个条件都加上索引，这时应该改为两次查询，然后用UNION ALL连接起来***

尽量不要包括多列排序，如果一定要，最好为这队列构建组合索引；

**一 索引的优缺点：**

1 快速检索，减少IO次数，加快索引速度；根据索引分组和排序，加快分组和排序

2 索引本身也是表，会占用存储空间；索引表的维护和创建需要时间成本，数据量越大，成本越大；构建索引会降低修改数据表的效率，因为修改数据表示也需要对索引表进行维护。

**二 索引分类**

主键索引：不允许重复，不允许空值

```
ALTER TABLE 'table_name' ADD PRIMARY KEY pk_index('col')；
```

唯一索引：唯一的，允许空值

```
ALTER TABLE 'table_name' ADD UNIQUE index_name('col')；
```

普通索引

```
alert table 'table_name' add index index_name('col');
```

全文索引：用大文本对象构建的列

```
alert table 'table_name' add fulltext index ft_index('col');
```

组合索引:多个列组合构建的索引，列中不允许有空值(遵循“最左前缀”原则，把最常用作为检索或排序的列放在最左，依次递减，组合索引相当于建立了col1，col1col2，col1col2col3三个索引，但col2，col3)

```
alert table 'table_name' add index index_name('col1','col2','col3');
```

使用索引时，可能因为列名长度过长导致索引的key太大，因尽量使用短索引，取列前几个字符作为索引

```
ALTER TABLE 'table_name' ADD INDEX index_name(col1(4),col2（3))；
```

**三 索引的实现原理**

1 哈希索引

用索引列的值计算hashcode的值，在hashcode的值存储该值的物理位置。散列算法让访问速度非常快，但同时一个值只能对应一个hashcode，并且是散列的分布方式，不能进行范围查询。

2 全文索引fulltext

生成fulltext索引时，会为文本生成一份单词清单，在索引时根据这个单词清单进行索引。

```
//创建表的时候添加FULLTEXT索引
CTREATE TABLE my_table(
    id INT(10) PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    my_text TEXT,
    FULLTEXT(my_text)
)ENGINE=MyISAM DEFAULT CHARSET=utf8;
//创建表以后，在需要的时候添加FULLTEXT索引
ALTER TABLE my_table ADD FULLTEXT INDEX ft_index(column_name);
```

全文索引的查询

```
SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
```

向一个没有全文索引的表中插入数据，然后建立全文索引的速度比向一个建立了全文索引的表中插入数据快。

mysql中全文索引支持英文。

5.6版本之后的innnodb也支持全文索引。

3 b树索引和b+树索引

b树与b+树的区别：1 b树是每一个节点中都存储数据，而b+树中只有叶子节点存储数据，且叶子节点上的数据是对应数据的物理地址。2 一个叶子节点包含指向下一个叶子节点的指针，提高范围查找的效率。

b+树对比b树的优点：

**数据库将整个节点的数据读入到内存中，在内存中进行查找**。因为内存的速度比外存读取io要快很多。所以**提升查找速度的关键在于尽可能少的磁盘IO**，那么每个节点中key个数越多，树的高度越小，需要IO的次数就越少，因此b+树比b树更快。因为b+树的非叶子节点中不存储data，可以存储更多的key。

查询速度稳定，因为b+树的所有数据都存储在叶子节点上，磁盘IO的次数都是树的高度，因此所有查询速度都是一样的。

**四 聚簇索引和非聚簇索引**

InnoDB*（不支持事务，表级锁，会保存表的具体行数）*--聚簇索引：聚簇索引的顺序就是数据物理存储顺序

1 主索引叶子节点的数据就是键值对数据本身，辅助索引叶子节点则存储主键索引。因此主键的值长度越小越好，类型越简单越好。

2 数据与主索引存储在一起

3 数据根据主键的顺序保存。因此适合按照主键索引的区间查找，可以有更少的磁盘IO，加快查询速度。也因此最好按照主键单调的顺序插入，否则会频繁的引起页分裂，影响性能。

4 InnoDB中，如果只需要查找索引的列，尽量不要加入其他列。

MyISAM*（支持事务，行级锁，不保存具体行数）*--非聚簇索引：索引顺序与物理排列顺序无关

1 主索引辅助索引几乎一样，叶子节点的数据都是指向对应真实数据的物理地址

2 数据表和索引表分开存储

3 数据根据数据的插入顺序保存，因此插入顺序不受键值影响，更适合单个数据的查询

理解：首先明白主索引与辅助索引，用主键键值建立的索引为主索引，其他的叫辅助索引。

**什么时候更适合使用聚簇索引**

当更多的时候使用主索引时，更适合使用聚簇索引。因为非聚簇索引在内存中找到对应键值对后要多一次IO去查找数据的真实地址。

**聚簇索引的存储维护**

在插入新数据时，聚簇索引的辅助索引指向的是主索引的键值，因此不用维护辅助索引，降低维护成本。但主索引存储的是数据本身，会占用更多空间。

**插入新数据时聚簇索引和非聚簇索引谁更快，为什么**

插入新数据时，非聚簇索引更快：1 主键的检测：是否重复？遍历所有叶节点。非聚簇索引保存数据地址，占用空间小，分布集中，查询的时候IO 更少，聚簇索引保存数据本身，占用空间大，需要多次IO 才能遍历完成。疑问：查到地址还需要对地址内的数据进行读取才能判断？，那么IO次数也不小。

